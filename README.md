# 파이썬 프로젝트 - 고객관리 프로그램

# 프로젝트 주제

- 고객관리 프로그램
    - 기존에 존재하던 프로젝트 명세서를 따라서 개발하였습니다.
    - 기존에 존재하던 프로젝트 주제는 **객체 지향 프로그래밍 기법**을 사용하여 고객관리 프로그램을 제작하는 것이었습니다.

## 객체 지향 프로그래밍이란 ?

**프로그램 구현에 필요한 객체를 파악하고 각각의 객체들의 역할이 무엇인지를 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말한다**.

- 말그대로 프로그램 자체를 하나하나의 장치를 만들어 연결해 하나의 기계를 완성하듯이 프로그래밍을 하는 것을 뜻합니다.

예를 들어서 마라톤을 하는 게임 프로그램을 개발한다 했을 때 , 해당 프로그램에 필요한 각각의 성질들을 하나의 객체 (물건처럼) 로 취급해 속성을 정의하고 , 조합해 하나의 완성품을 만드는 것과 같습니다.

→ 마라톤을 하기 위해선 ? ⇒ 사람이 필요하다. (사람의 속성을 정의하고, 달리는 행동을 정의한다.) ⇒ 참가자의 참가 명단을 확인하기위한 관리 명단이 필요하다. (사람을 어떻게 추가,삭제,수정,조회 할지 정의한다.) ⇒ 하나의 게임을 하기위한 경기장이 필요하다. (어떻게 게임을 시작할지, 게임을 시작하면 어떻게 참가자의 행동을 관리할지 등등을 정의)

이러한 방식으로 작은 객체부터 **하나하나 정의하여 마치 레고를 조립하듯이 서로의 연관관계를 정의하며 프로그램을 완성하는 기법**입니다.

![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled.png)

## 왜 해당 프로젝트 주제를 선정했는가 ?

파이썬은 보통 통계, 데이터분석 등등에 자주 사용되기 때문에 객체지향 개념을 자주 사용하진 않는걸로 알고있지만, 결론적으로 **파이썬은 class 를 생성해 해당 클래스에 행동을 정의하고 속성을 정의할 수 있도록 되어있기때문에**, 객체지향적인 부분을 살려서 프로그래밍 할 수 있다고 생각했습니다.

그리고 파이썬을 사용해보진 않았지만 , 객체지향에 대한 개념을 잘잡을수록 , 다른 언어 혹은 프레임워크를 사용할 때 기본적으로 하나의 동작을 구현하기 위한 벽이 점점 낮아진다고 생각했습니다.

→ 객체를 설계할때 하게되는 고민들이 프로그래밍의 기본적인 설계에 대한 고민과 비슷하다고 느꼈기 때문입니다.

## 객체지향 5원칙

![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled%201.png)

- 객체지향의 5원칙에는 이러한 요소가 존재하지만 , 그중 가장 중요하다 생각하는 것들의 예를 들어보았습니다.
    - 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 합니다.
        - 기본적으로 하나의 클래스를 생성할 때, 해당 클래스가 어디서부터 어디까지의 일을 하더라도 그게 하나의 물건으로써 책임이어야 합니다. (커피기계이지만 설겆이를 하면 안됩니다.)
    - 개방 폐쇄 원칙 : 확장에는 열려있으나 변경에는 닫혀있어야 한다.
        - 네트워크와 비슷합니다. 케이블로 연결하여 라우터 스위치 등등으로 인한 확장에는 열려있지만 , 의존관계로 인해 연결되있는 무언가를 함부로 변경하면 안됩니다.

저는 이번 프로젝트의 크기에 맞춰서 이 두 원칙을 중요하게 생각하고 진행했습니다.

# 프로젝트 설명

## 프로젝트 명세

프로젝트 주제는 제가 직접 처음부터 끝까지 설계한 것이 아닌 , **기존에 제가 직접 구현하고 설계해야 하는 것들이 정해져있는 주제**를 가져와서 진행했습니다.

![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled%202.png)

→ 고객 분류 프로그램으로 , 고객의 명단을 입력받고 , 고객의 특정 속성을 기준치에 따라 각각의 등급으로 분류하고 출력하도록 하는 프로그램입니다.

![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled%203.png)

프로젝트의 전체적인 주제는 각각의 클래스(객체) 에 어떠한 역할을 부담시키고, 어떠한 행동을 하였을때 발생할 수 있는 문제를 프로그램의 종료 없이 깔끔하게 처리할 수 있는지 였습니다.

![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled%204.png)

전체적으로 설계해야 하는 도메인은 customer, group, menu 이렇게 세개로 분리되어있습니다.

- (간단히 말하면 **해결하고자 하는 문제의 영역** 을 도메인이라고한다. 소프트웨어 입장에서 다시 해석하면 개발하고자 하는 소프트웨어의 요구사항 , 문제 영역 정도로 생각할 수 있다.)

## 전체적인 설계 방향

저는 기존에 자바를 이용하여 웹 서버를 구축해봤던 경험이 있습니다.

자바 언어로 프로젝트를 진행했을 땐 , 싱글톤 패턴을 이용하여 프로젝트를 진행했으며, 파이썬에서의 객체지향 개념을 잘 알지 못했기 때문에, 기존에 알고있는 형식으로 진행해보자 생각하여 싱글톤 패턴을 주로 두고 진행했습니다.

- 싱글톤 패턴이란 ?
    - 생성자가 여러 차례 호출되더라도 실제로 생성되는 객체는 하나이고 최초 생성 이후에 호출된 생성자는 최초의 생성자가 생성한 객체를 리턴한다. 이와 같은 디자인 유형을 싱글턴 패턴이라고 한다.
        - 말그대로 하나의 프로그램에서 하나만 생성되어야 하는 객체 (예 : 고객 명단 , 즐겨찾기 명단, 카트 목록 등등) 는 하나만 생성해서 관리하도록 합니다.

해당 프로젝트에서는 전체적으로 하나의 객체만 생성하여 관리해야 할 것은 고객명단을 관리할 클래스 , 그룹 리스트를 관리할 클래스, 그리고 메뉴를 출력할 클래스  이렇게 세개라고 생각했습니다.
가

### Customer 도메인

- Customer
    - Customer 클래스
    
    ![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled%205.png)
    
    - 기본적으로 해당 프로그램의 주체가 되는 고객의 속성을 정의하는 클래스입니다.
    - 클래스의 기본 변수로 현재 고객 수 를 갖는 변수를 선언해 , **고객이 하나씩 입력될 때 마다 해당 변수의 값을 더해 고유 번호로 갖도록** 했습니다.
    - 객체 자체는 다른 객체와 비교했을 때 , **고유 번호는 절대로 같은 번호가 두개 이상 부여받도록구현하지 않았기 때문에, 고유 번호가 같으면 같은 객체로 인식하도록** 구현했습니다.
    - Customers 클래스
    
    ![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled%206.png)
    
    - 고객의 명단을 담을 클래스로 , 변수로는 Customer 객체를 담을 배열 하나만 생성하여 함수로는 해당 명단을 관리할 함수들 (추가,삭제,수정,조회) 등등을 선언했습니다.
- ClassifiedCustomers 클래스

![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled%207.png)

- 분류된 고객을 담고 프로젝트 명세서대로 정렬하여 해당 명단을 반환할 함수들을 정의했습니다.
    - 명단은 **딕셔너리 형태**로 키 (그룹타입) : 밸류 (고객) 을 갖도록 선언했습니다.
- 전체적으로 고객 도메인은 설계할 때 , **각각의 책임이 어디서부터  어디까지를 가질지 고민함과 동시에** 명단을 관리할 Customers 의 자료구조를 어떤걸 사용할지 고민했습니다.
    - 각각의 책임은 단순히 **Customer은 고객, Customers는 고객을 관리할 단순 명단, Classified Customers 는 단순 정렬된 리스트를 반환하는 역할**만 정해두었습니다.
    - 자료구조는 Customers 같은 경우엔 단순 고객명단만 출력할 시에는 등록 순서대로 출력이 되길 원했기 때문에, **추가/삭제에 용이한 Hash 자료구조 를 사용해서 기본 명단을 출력할때마다 고유번호대로 정렬하지 않도록 하고 단순히 리스트 자료구조**를 사용하였습니다.

### Group 도메인

- Group
    
    ![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled%208.png)
    
    - Group 클래스는 단순히 그룹이라는 열거형 타입을 사용하지 않고 , 부가 설명을 할 수 있는 속성들을 가진 이름표 처럼 정의하였습니다.
        - 따로 그룹 클래스에 기준이 되는 이용 시간과 금액을 변수로 사용하지 않고 , Parameter 라는 클래스를 따로 생성하여 기준 시간 / 금액을 정의하도록 정의했습니다.
        - GroupType 은 명세서에 정의되어있는 GENERAL , VIP , VVIP 3개의 타입과 분류가 되지 않은 타입을 관리할 NONE 타입까지 4개의 타입을 정의했습니다.
- Groups
    
    ![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled%209.png)
    
    - Groups 클래스는 Customers 클래스와 마찬가지로 프로그램 전체에서 하나의 객체만 이용하여 관리해야 하기 때문에 **싱글톤 패턴**으로 구현했습니다.
        - 기본으로 초기화되는 Groups 리스트는 각각의 그룹 타입과 기준이되는 파라미터를 담은 Group 객체를 기본으로 갖고 생성되도록 구현했습니다.
        - 마찬가지로 해당 클래스의 역할은 단순히 Group ‘들’ 을 관리하도록 구현했고, 각각 그룹의 기준을 수정하거나 초기화 하는 행동정도만을 담은 함수들을 선언했습니다.

### Menu 도메인

- Menu
    
    ![Untitled](%E1%84%91%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8A%E1%85%A5%E1%86%AB%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%8C%E1%85%A6%E1%86%A8%E1%84%90%E1%85%B3%20-%20%E1%84%80%E1%85%A9%E1%84%80%E1%85%A2%E1%86%A8%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%86%B7%20b3bf347cb23e493f9e124b4a2d6e3f3b/Untitled%2010.png)
    
    - Menu 클래스는 다른 하위 클래스가 상속받을 수 있도록 추상 클래스로 선언하였습니다.
    - 각각의 클래스에서 공통적으로 사용할 기능들 (메뉴 출력, 선택한 번호 입력받기 등) 을 선언하여 각각의 클래스에서 재정의 하도록 구현했습니다.
- 각각의 Menu
    - 각각의 메뉴는 전체적으로 Customers, ClassifiedCustomers, Groups 가 갖고있는 함수들을 2차적으로 호출해 가공한 데이터를 매개변수로 전달하고 결과를 전달받아 출력하거나 에러가 발생할 때 예외를 처리하도록 구현했습니다.
        - 깔끔한 사용자 경험을 위해 While 문으로 메뉴를 반복 출력하고 선택하도록 해 하나의 입력 실수가 발생할 때 ,  최대 3개~4개의 뒤로가기가 발생하지 않도록 구현했습니다.
        - **Customer 는 계정 , Customers 는 서버 혹은 데이타베이스, CustomerMenu 는 웹페이지 같이 생각하면 됩니다.**
    - CustomerMenu
        - 해당 메뉴는 기본적으로 **고객 명단의 추가, 삭제, 수정, 조회** 가 가능하도록 구현했고 아이디의 중복 확인, 혹은 일정한 패턴의 검증 (예 : ID가 3자리 이상 등등) 의 **부가적인 기능을 담당**해 Customers 는 단순 명단에 객체를 추가하고, **예외적인 부분을 Menu에서 처리하도록 구현**했습니다.
    - GroupMenu
        - 해당 메뉴또한 마찬가지로 그룹의 기준 초기화, 수정, 기준조회가 가능하도록 구현했고 각 그룹의 기준이 충돌하는지 검증 후 반영을 시키도록 구현했습니다.
    - SummaryMenu
        - 최종적으로 그룹의 기준이 초기화 되어있고 명단에 고객이 1명 이상 등록이 되어있을때 사용이 가능한 요약조회 메뉴로써, 각각 속성별로 정렬된 명단을 출력하거나 내보낼 수 있도록 구현했습니다.
            - ClassifiedCustomers 클래스에서 정렬된 명단을 return 값으로 받아와 해당 명단을 가공하여 깔끔하게 출력하거나 엑셀 파일로 내보낼 수 있도록 구현했습니다.

# 프로그램 주요 기능

- 고객 관리 기능
    - 고객 추가
        - 고객의 아이디는 중복될 수 없으며 , 고객의 이름은 특정한 패턴이 아니면 등록이 되지 않습니다.
        - 엑셀 파일을 불러와 열, 행을 지정하여 프로그램에 정해둔 패턴과 중복되지 않은 아이디를 가진 명단을 추가 할 수 있습니다.
    - 고객 삭제
        - 고객의 고유 번호를 참조하여 고객을 명단에서 삭제할 수 있습니다.
    - 고객 수정
        - 고객의 고유 번호를 참조하여 고객의 아이디, 이름, 이용 금액 / 시간 을 수정 할 수 있습니다.
    - 고객 조회
        - 고객의 그룹을 포함하지 않은 고객 명단을 조회 할 수 있습니다 .
- 그룹 관리 기능
    - 그룹 기준 초기화
        - 고객을 분류할 기준을 초기화 할 수 있습니다.
            - 각 그룹별로 분류할 기준을 설정 할 수 있습니다.
            - 각 그룹이 다른 그룹의 기준을 침범 할 수 없습니다.
    - 그룹 기준 수정
        - 그룹 기준을 수정하여 다시 고객을 재 분류 할 수 있습니다.
    - 그룹 기준 조회
        - 그룹 기준이 초기화 된 상황이라면 그룹 기준을 조회하고 , 아니라면 되돌아갑니다.
- 요약 조회 기능
    - 요약 조회
        - 그룹의 기준별로 나뉘어진 고객 명단을 원하는 순서대로 정렬 후 조회가 가능합니다.
        - 고객의 이름 순 (오름차 , 내림차순) , 고객 이용 금액 / 시간 순 (오름차, 내림차순) 으로 조회가 가능합니다.
    - 엑셀로 내보내기
        - 고객의 명단을 엑셀 파일로 내보내기 할 수 있습니다.
    

# 프로젝트 진행하면서 신경 쓴 부분

- 예외 처리에 대하여 신경쓴 부분이 많았습니다.
    - 프로그램에 있어서 가장 중요한 부분은 개인적으로 이용자가 얼마나 쾌적한 경험을 할 수 있도록 구현했느냐 라고 생각합니다.
        - 따라서 어떠한 기능을 이용할 때 비정상적으로 종료 된다거나 , 다시 처음의 메뉴로 돌아가는 등의 행동을 하지 않도록 예외처리에 많은 신경을 써보았습니다.
- 기존의 프로그램 명세에 존재하지 않는 편의성을 추가하였습니다.
    - 파이썬의 장점은 아무래도 간단한 코드와 , 자동화 기능을 가진 라이브러리가 많은 것이라고 생각했습니다.
    - 기존의 프로젝트에는 엑셀로 내보내기, 불러오기 같은 내용은 존재하지 않았지만 ,파이썬이 가진 장점을 활용하기 위해 pyxl 을 사용하여 엑셀 기능을 추가하였습니다.
- 코드의 전체적인 깔끔함과 구성에 신경썼습니다.
    - 기본적으로 파이썬이 가지는 규칙 (예를 들어 .py 파일의 마지막 줄이 공백이어야 하는 등) 을 지키려 노력했고 , 각 클래스간의 의존관계를 최대한 줄여 하나를 수정할 때 프로그램의 구동에 최대한 피해가 가는 부분이 없도록 구현하려고 노력했습니다.

## 프로그램 시연

# 마무리

### 구현 코드 : 깃허브 → brince0304 → **[python-member-manage-program](https://github.com/brince0304/python-member-manage-program)**

감사합니다.
